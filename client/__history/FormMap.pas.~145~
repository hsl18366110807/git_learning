unit FormMap;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  ChatProtocol, Vcl.StdCtrls, ChatManager, GR32, GR32_Image, GR32_PNG,
  Vcl.ExtCtrls, System.DateUtils;

type
  TFrmMap = class(TForm)
    pntbx: TPaintBox32;
    pnl1: TPanel;
    lbl2: TLabel;
    lbl3: TLabel;
    lbl4: TLabel;
    lbl5: TLabel;
    lbl6: TLabel;
    lbl7: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure doWork(Sender: TObject);
    procedure processAni(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    function FindInList(const UserList: TUserList; role: TPlayerInfo): Integer;
//    procedure RoleMoveOneStepY;
    procedure RoleMoveOneStepY(Role: TBitmap32; SrcX, SrcY, DesY: Integer);
//    procedure RoleMoveOneStepX;
    procedure RoleMoveOneStepX(Role: TBitmap32; SrcY, SrcX, DesX: Integer);
    procedure DrawMap;
    procedure DrawPlayer;
    procedure InitPlayerList;
    procedure SetShoes(Ptr: PTShoesInfo);
    procedure SetBomb(Ptr: PTBombSeted);
    procedure SetBombBoom(Ptr: PTBombBoom);
    procedure PlayerMove(DesPlayer: PTPlayerInfo);
    procedure DrawMapAndPlayer(Sender: TObject);
    procedure AddMoveList(MovePtr: PTOneMove);
    procedure AddBoomList(BoomPtr: PTBoomPic);
    procedure AddBoomFireList(FirePtr: PTBoomFirePic);
    procedure processMove;
    procedure MoveCheckMap(X, Y: Integer);
    procedure DrawBoom;
    procedure DrawBoomFire;
    procedure CheckBoomRange(Ptr: PTBombBoom);
    function FindUserFromList(Id: Integer): PTPlayerInfo;
    function AddUserToList(Ptr: PTPlayerInfo): Integer; // -1 失败 0 成功 1 用户列表已满
    function UpdateUserToList(Ptr: PTPlayerInfo): Integer; // -1 失败 0 成功  1 失败，没有找到要更新的用户
    function IsInMoveList(Id: Integer): Boolean;
    function IsMoveListEmpty: Boolean;
    function IsBoomListEmpty: Boolean;
    function IsBoomFireListEmpty: Boolean;
//    procedure tmr1Timer(Sender: TObject);
  private
    FBmpRole: TBitmap32;
    FBmpBoom: TBitmap32;
    FBmpShoe: TBitmap32;
    Fmsgs: TChatMsgs;
    FSrcX, FSrcY, FDesX, FDesY: Integer;
    FMovingRoleIndex: Integer;
    FNewTime, FOldTime: TDateTime;
    bmpRoleW, bmpRoleH, piceRoleW: Integer;
    bmpBoomW, bmpBoomH, piceBoomW: Integer;
    timer: TTimer;
    TickForRole: Integer;
    TickForBomb: Integer;
    color: TColor;
    posX, posY: Integer;
    FOldMap: array of Integer;
    FMap: array of Integer;
    FUsersChanged: Boolean;
    FUserListNew: TUserList; // array[0..4] of TPlayerInfo;
    FUserListOld: TUserList;
    FUserList: TUserList;
    FMoveListBegin: PTOneMove;
    FMoveListEnd: PTOneMove;
    FBoomListBegin: PTBoomPic;
    FBoomListEnd: PTBoomPic;
    FBoomFireListBegin: PTBoomFirePic;
    FBoomFireListEnd: PTBoomFirePic;
    { Private declarations }
  public
    { Public declarations }
  end;

var
  FrmMap: TFrmMap;

implementation

{$R *.dfm}

const
  W = 40;

var
  bmp2, bmp3, bmp4: TBitmap32;
  bmpE, bmpWW, bmpS, bmpN: TBitmap32;
  tick: Integer;
  bmpFireE, bmpFireW, bmpFireN, bmpFireS: TBitmap32;
  bmpFireCenter, bmpFireEEnd, bmpFireWEnd, bmpFireNEnd, bmpFireSEnd: TBitmap32;

procedure TFrmMap.AddBoomList(BoomPtr: PTBoomPic);
begin
  if FBoomListBegin = nil then
  begin
    FBoomListBegin := BoomPtr;
    FBoomListEnd := BoomPtr;
  end
  else
  begin
    FBoomListEnd.Next := BoomPtr;
    FBoomListEnd := FBoomListEnd.Next;
  end;

end;

procedure TFrmMap.AddBoomFireList(FirePtr: PTBoomFirePic);
begin
  if FBoomFireListBegin = nil then
  begin
    FBoomFireListBegin := FirePtr;
    FBoomFireListEnd := FirePtr;
  end
  else
  begin
    FBoomFireListEnd.Next := FirePtr;
    FBoomFireListEnd := FBoomFireListEnd.Next;
  end;
end;

procedure TFrmMap.AddMoveList(MovePtr: PTOneMove);
begin
  if FMoveListBegin = nil then
  begin
    FMoveListBegin := MovePtr;
    FMoveListEnd := MovePtr;
  end
  else
  begin
    FMoveListEnd.Next := MovePtr;
    FMoveListEnd := FMoveListEnd.Next;
  end;
end;

function TFrmMap.AddUserToList(Ptr: PTPlayerInfo): Integer;
var
  I: Integer;
begin
  if Ptr = nil then
  begin
    Result := -1;
    Exit
  end;
  for I := 0 to Length(FUserList) - 1 do
  begin
    if FUserList[I].UserID = 0 then
    begin
      FUserList[I] := Ptr^;
      Result := 0;
      Exit
    end;
  end;
  if I = Length(FUserList) - 1 then
    Result := 1;
end;

procedure TFrmMap.CheckBoomRange(Ptr: PTBombBoom);
var
  I: Integer;
  DestoryArray: TArrayOfBoomDestroy;
  DestoryX, DestoryY: Integer;
begin
  DestoryArray := Ptr^.DestoryPos;
  for I := 0 to Length(DestoryArray) - 1 do
  begin
    if DestoryArray[I][0] <> -1 then
    begin
      DestoryX := DestoryArray[I][0];
      DestoryY := DestoryArray[I][1];
      FMap[DestoryX * 20 + DestoryY] := 0;
    end;
  end;
end;

procedure TFrmMap.doWork(Sender: TObject);
var
  MsgPtr: PChatMsg;
  ServerMsgPtr: PServerMessage;
  MapPtr: PTSMap;
  UserPtr: PTPlayerInfo;
  UserListPtr: PTPlayerInfoList;
  BoomFlor: PTBombBoom;
  ShoesPtr: PTShoesInfo;
  BombPtr: PTBombSeted;
  BombBoomPtr: PTBombBoom;
begin
  ChatMgr.ReadResponse(FMsgs);
  while not FMsgs.IsEmpty do
  begin
    FMsgs.FetchNext(MsgPtr);

    if MsgPtr <> nil then
    begin
      ServerMsgPtr := PServerMessage(MsgPtr);
      try
        case ServerMsgPtr^.Head.Command of
          S_MAP:
            begin
              MapPtr := PTSMap(MsgPtr);
              CopyMemory(FMap, @MapPtr^.Map[0], 1600);
            end;
          S_USERLIST:
            begin
              UserListPtr := PTPlayerInfoList(MsgPtr);
              FUserList := UserListPtr^.UserList;
//              FUsersChanged := True;
            end;
          S_PlayerInfo:
            begin
              UserPtr := PTPlayerInfo(MsgPtr);
              AddUserToList(UserPtr);
            end;
          S_PLAYERMOVE:
            begin
              UserPtr := PTPlayerInfo(MsgPtr);
              PlayerMove(UserPtr); //以我现在写的move逻辑的话，多人同时动的话可能存在问题
            end;
          S_SETSHOES:
            begin
              ShoesPtr := PTShoesInfo(MsgPtr);
              SetShoes(ShoesPtr);   //鞋子的动画还要加上
            end;
          S_SETBOME:
            begin
              BombPtr := PTBombSeted(MsgPtr);
              SetBomb(BombPtr);
            end;
          S_BOMBBOOM:
            begin
              BombBoomPtr := PTBombBoom(MsgPtr);
              SetBombBoom(BombBoomPtr);
            end;
        end;
      finally
        FreeMem(MsgPtr);
      end;
    end;
  end;
//  processAni(self);
  DrawMapAndPlayer(self);
end;

procedure TFrmMap.DrawBoom;
var
  Ptr: PTBoomPic;
  drawY, TickForBomb, x, y, bmpBombH: Integer;
begin
  Ptr := FBoomListBegin;
  while Ptr <> nil do
  begin
    TickForBomb := Ptr^.Tick;
    bmpBombH := FBmpBoom.Height;
    x := Ptr^.PosX * 40;
    y := Ptr^.PosY * 40;
    drawY := y - (bmp4.Height - 40);
    FBmpBoom.DrawTo(pntbx.Buffer, rect(x, drawY, piceBoomW + x, drawY + bmpBombH), Rect(piceBoomW * TickForBomb, 0, piceBoomW * (TickForBomb + 1), bmpBombH));
    Inc(Ptr^.Tick);
    if Ptr^.Tick = 4 then
      Ptr^.Tick := 0;
    Ptr := Ptr.Next;
  end;
end;

procedure TFrmMap.DrawBoomFire;
var Ptr: PTBoomFirePic;
begin
  Ptr := FBoomFireListBegin;
  while Ptr <> nil do
  begin
  if Ptr^.Tick = 4 then
      Ptr^.Tick := 0;
    Ptr := Ptr.Next;
  end;
end;

procedure TFrmMap.DrawMap;
var
  x, y, i, j, drawY, bmpBombH, PosX, PosY: Integer;
begin
  x := 0;
  y := 0;
  while x < 800 do
  begin
    while y < 800 do
    begin
      bmp2.DrawTo(pntbx.Buffer, x, y);
      y := y + 40;
    end;
    x := x + 40;
    y := 0;
  end;

  //画地板
  x := 0;
  y := 0;
  while x < 800 do
  begin
    while y < 800 do
    begin
      i := x div 40;
      j := y div 40;
      if FMap[i * 20 + j] = 1 then //地板//
      begin
        drawY := y - (bmp3.Height - 40);
        bmp3.DrawTo(pntbx.Buffer, x, drawY);
      end
      else if FMap[i * 20 + j] = 2 then  //箱子
      begin
        drawY := y - (bmp4.Height - 40);
        bmp4.DrawTo(pntbx.Buffer, x, drawY);
      end
      else if FMap[i * 20 + j] = 4 then
      begin
//        drawY := y - (bmp4.Height - 40);
//        FBmpBoom.DrawTo(pntbx.Buffer, rect(x, drawY, piceBoomW + x, drawY + bmpBombH), Rect(piceBoomW * TickForBomb, 0, piceBoomW * (TickForBomb + 1), bmpBombH));
//        Inc(TickForBomb);
//        if TickForBomb = 4 then
//          TickForBomb := 0;
      end
      else if FMap[i * 20 + j] = 5 then //鞋子
      begin
        drawY := y - (FBmpShoe.Height - 40);
        FBmpShoe.DrawTo(pntbx.Buffer, x, drawY);
      end;
      y := y + 40;
    end;
    x := x + 40;
    y := 0;
  end;
  if not IsBoomListEmpty then
    DrawBoom;
  if not IsBoomFireListEmpty then
    DrawBoomFire;
end;

procedure TFrmMap.DrawMapAndPlayer(Sender: TObject);
begin
  DrawMap;
  DrawPlayer;
  pntbx.Invalidate;
end;

procedure TFrmMap.DrawPlayer;
var
  I: Integer;
  PosX, PosY: Integer;
  BmpRole: TBitmap32;
  tick: Integer;
begin
  for I := 0 to Length(FUserList) do
  begin
    if FUserList[I].UserID <> 0 then
    begin
      if not IsInMoveList(FUserList[I].UserID) then
      begin
        case FUserList[I].FaceTo of
          SOUTH:
            BmpRole := bmpS;
          NORTH:
            BmpRole := bmpN;
          EAST:
            BmpRole := bmpE;
          WEST:
            BmpRole := bmpWW;
        end;
        if FUserList[I].UserID = ChatMgr.ReadPlayerInfo^.UserID then
        begin
          case FUserList[I].FaceTo of
            SOUTH:
              lbl5.Caption := 'SOUTH';
            NORTH:
              lbl5.Caption := 'NORTH';
            EAST:
              lbl5.Caption := 'EAST';
            WEST:
              lbl5.Caption := 'WEST';
          end;
          lbl3.Caption := IntToStr(FUserList[I].Speed);
          lbl7.Caption := IntToStr(FUserList[I].UserID);
        end;

        PosX := FUserList[I].UserPosX * 40;
        PosY := FUserList[I].UserPosY * 40 - (FBmpRole.Height - 40);
        BmpRole.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(0, 0, piceRoleW, bmpRoleH));
        FUserListOld := FUserListNew;
      end;
    end;
  end;
  if not IsMoveListEmpty then
    processMove;
end;

function TFrmMap.FindInList(const UserList: TUserList; role: TPlayerInfo): Integer;
var
  i, j: Integer;
  tmpRole: TPlayerInfo;
begin
  Result := -1;
  for i := 0 to Length(UserList) do
  begin
    tmpRole := UserList[i];
    j := 0;
    while (tmpRole.UserName[j] = role.UserName[j]) and (j <= Length(role.UserName) - 1) do
      Inc(j);
    if j = Length(role.UserName) then
      Result := i;
  end;
end;

function TFrmMap.FindUserFromList(Id: Integer): PTPlayerInfo;
var
  I: Integer;
begin
  for I := 0 to Length(FUserList) - 1 do
  begin
    if FUserList[I].UserID = Id then
    begin
      Result := @FUserList[I];
      Exit
    end;
  end;
  if I = Length(FUserList) - 1 then
    Result := nil;
end;

procedure TFrmMap.FormCreate(Sender: TObject);
begin
//
  FMsgs := TChatMsgs.Create;
  ChatMgr.RequestMap;
//  InitPlayerList;
//  AddUserToList(ChatMgr.ReadPlayerInfo);
  FBmpRole := TBitmap32.Create;
  bmpE := TBitmap32.Create;
  bmpWW := TBitmap32.Create;
  bmpN := TBitmap32.Create;
  bmpS := TBitmap32.Create;
  FBmpShoe := TBitmap32.Create;
  FBmpBoom := TBitmap32.Create;
  bmpFireE := TBitmap32.Create;
  bmpFireW := TBitmap32.Create;
  bmpFireN := TBitmap32.Create;
  bmpFireS := TBitmap32.Create;
  bmpFireEEnd := TBitmap32.Create;
  bmpFireWEnd := TBitmap32.Create;
  bmpFireNEnd := TBitmap32.Create;
  bmpFireSEnd := TBitmap32.Create;
  bmpFireCenter := TBitmap32.Create;
  FBmpRole.DrawMode := dmTransparent;
  bmpE.DrawMode := dmBlend;
  bmpN.DrawMode := dmBlend;
  bmpS.DrawMode := dmBlend;
  bmpWW.DrawMode := dmBlend;
  FBmpShoe.DrawMode := dmBlend;
  FBmpBoom.DrawMode := dmBlend;
  bmpFireCenter.DrawMode := dmBlend;
  bmpFireW.DrawMode := dmBlend;
  bmpFireN.DrawMode := dmBlend;
  bmpFireS.DrawMode := dmBlend;
  bmpFireE.DrawMode := dmBlend;
  bmpFireEEnd.DrawMode := dmBlend;
  bmpFireWEnd.DrawMode := dmBlend;
  bmpFireNEnd.DrawMode := dmBlend;
  bmpFireSEnd.DrawMode := dmBlend;
  LoadBitmap32FromPNG(FBmpRole, 'img/redp_m_east.png');
  LoadBitmap32FromPNG(bmpE, 'img/redp_m_east.png');
  LoadBitmap32FromPNG(bmpN, 'img/redp_m_north.png');
  LoadBitmap32FromPNG(bmpS, 'img/redp_m_south.png');
  LoadBitmap32FromPNG(bmpWW, 'img/redp_m_west.png');
  LoadBitmap32FromPNG(FBmpBoom, 'img/bomb.png');
  LoadBitmap32FromPNG(FBmpShoe, 'img/shoe.png');
  LoadBitmap32FromPNG(bmpFireCenter, 'img/bbf_center.png');
  LoadBitmap32FromPNG(bmpFireW, 'img/bbf_west.png');
  LoadBitmap32FromPNG(bmpFireWEnd, 'img/bbf_west_end.png');
  LoadBitmap32FromPNG(bmpFireN, 'img/bbf_north.png');
  LoadBitmap32FromPNG(bmpFireNEnd, 'img/bbf_north_end.png');
  LoadBitmap32FromPNG(bmpFireS, 'img/bbf_south.png');
  LoadBitmap32FromPNG(bmpFireSEnd, 'img/bbf_south_end.png');
  LoadBitmap32FromPNG(bmpFireE, 'img/bbf_east.png');
  LoadBitmap32FromPNG(bmpFireEEnd, 'img/bbf_east_end.png');
  bmpRoleW := FBmpRole.Width;
  bmpRoleH := FBmpRole.Height;
  piceRoleW := bmpRoleW div 6;
  bmpBoomW := FBmpBoom.Width;
  bmpBoomH := FBmpBoom.Height;
  piceBoomW := bmpBoomW div 4;

  bmp2 := TBitmap32.Create;
  LoadBitmap32FromPNG(bmp2, 'img/floor1.png');

  bmp3 := TBitmap32.Create;
  bmp3.DrawMode := dmBlend;
  LoadBitmap32FromPNG(bmp3, 'img/cookie1.png');

  bmp4 := TBitmap32.Create;
  bmp4.DrawMode := dmBlend;
  LoadBitmap32FromPNG(bmp4, 'img/box1.png');

  PosX := 0;
  PosY := 0;

  SetLength(FMap, 400);
  FillMemory(FMap, 400, 0);

  timer := TTimer.Create(Self);
  timer.OnTimer := doWork;
  timer.Interval := 100;
  timer.Enabled := True;
  FMovingRoleIndex := -1;
  FOldTime := Now;
  FNewTime := Now;
end;

procedure TFrmMap.FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if Key = 32 then
  begin
    ChatMgr.RequestBoom;
    exit;
  end;
  FNewTime := Now;
  if (TickForRole = 0) and (FMovingRoleIndex = -1) and (SecondsBetween(FNewTime, FOldTime) > 0.1) then
  begin
    ChatMgr.RequestMove(Key);
    FOldTime := Now;
  end;

end;

procedure TFrmMap.InitPlayerList;
var
  I: Integer;
begin
  for I := 0 to Length(FUserList) - 1 do
  begin
    FUserList[I].UserID := -1;
  end;

end;

function TFrmMap.IsInMoveList(Id: Integer): Boolean;
var
  ptr: PTOneMove;
begin
//
  Result := False;
  if FMoveListBegin = nil then
    Exit;
  ptr := FMoveListBegin;
  while ptr <> nil do
  begin
    if ptr^.UserId = Id then
    begin
      Result := True;
      Exit;
    end
    else
      ptr := ptr^.Next;
  end;
end;

function TFrmMap.IsMoveListEmpty: Boolean;
begin
  Result := False;
  if FMoveListBegin = nil then
    Result := True;
end;

procedure TFrmMap.MoveCheckMap(X, Y: Integer);
begin
  if FMap[X * 20 + Y] = 5 then
    FMap[X * 20 + Y] := 0;

end;

function TFrmMap.IsBoomFireListEmpty: Boolean;
begin
  Result := False;
  if FBoomFireListBegin = nil then
    Result := True;
end;

function TFrmMap.IsBoomListEmpty: Boolean;
begin
  Result := False;
  if FBoomListBegin = nil then
    Result := True;
end;

procedure TFrmMap.PlayerMove(DesPlayer: PTPlayerInfo);
var
  id: Integer;
  SrcPlayerPtr: PTPlayerInfo;
  SrcX, SrcY, DesX, DesY: Integer;
  MovePtr: PTOneMove;
begin
  id := DesPlayer^.UserID;
  SrcPlayerPtr := FindUserFromList(id);
  if (SrcPlayerPtr^.UserPosX = DesPlayer^.UserPosX) and (SrcPlayerPtr^.UserPosY = DesPlayer^.UserPosY) then
  begin
    UpdateUserToList(DesPlayer);
    Exit;
  end;

  MovePtr := AllocMem(SizeOf(TOneMove));
  MovePtr^.Next := nil;
  MovePtr^.UserId := id;
  MovePtr^.SrcX := SrcPlayerPtr^.UserPosX;
  ;
  MovePtr^.SrcY := SrcPlayerPtr^.UserPosY;
  MovePtr^.DesX := DesPlayer^.UserPosX;
  MovePtr^.DesY := DesPlayer^.UserPosY;
  MovePtr^.FaceTo := DesPlayer^.FaceTo;
  AddMoveList(MovePtr);
  UpdateUserToList(DesPlayer);
end;

procedure TFrmMap.SetBomb(Ptr: PTBombSeted);
var
  PosX, PosY: Integer;
  BoomPtr: PTBoomPic;
begin
  BoomPtr := AllocMem(SizeOf(TBoomPic));
  BoomPtr^.Next := nil;
  BoomPtr^.PosX := Ptr^.BombPosX;
  BoomPtr^.PosY := Ptr^.BombPosY;
  BoomPtr^.tick := 0;
  AddBoomList(BoomPtr);
end;

procedure TFrmMap.RoleMoveOneStepY(Role: TBitmap32; SrcX, SrcY, DesY: Integer);
var
  piceRoleW, bmpRoleH: Integer;
  PosX, PosY: Integer;
begin
  piceRoleW := Role.Width div 6;
  if SrcY < DesY then
  begin
    bmpRoleH := Role.Height;
    PosX := SrcX * 40;
    PosY := SrcY * 40 - (bmpRoleH - 40) + (tick + 1) * 40 div 6;
    Role.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(piceRoleW * tick, 0, piceRoleW * (tick + 1), bmpRoleH));
  end
  else
  begin
    bmpRoleH := Role.Height;
    PosX := SrcX * 40;
    PosY := SrcY * 40 - (bmpRoleH - 40) - (tick + 1) * 40 div 6;
    Role.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(piceRoleW * tick, 0, piceRoleW * (tick + 1), bmpRoleH));
  end;
end;

procedure TFrmMap.RoleMoveOneStepX(Role: TBitmap32; SrcY, SrcX, DesX: Integer);
var
  piceRoleW, bmpRoleH: Integer;
  PosX, PosY: Integer;
begin
  piceRoleW := Role.Width div 6;
  if SrcX < DesX then
  begin
    bmpRoleH := Role.Height;
    PosX := SrcX * 40 + (tick + 1) * 40 div 6;
    PosY := SrcY * 40 - (bmpRoleH - 40);
    Role.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(piceRoleW * tick, 0, piceRoleW * (tick + 1), bmpRoleH));
  end
  else
  begin
    bmpRoleH := Role.Height;
    PosX := SrcX * 40 - (tick + 1) * 40 div 6;
    PosY := SrcY * 40 - (bmpRoleH - 40);
    Role.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(piceRoleW * tick, 0, piceRoleW * (tick + 1), bmpRoleH));
  end;
end;

procedure TFrmMap.SetBombBoom(Ptr: PTBombBoom);
var
  BoomPtr: PTBoomPic;
  BoomFirePtr: PTBoomFirePic;
begin
//炸弹消失
  BoomPtr := FBoomListBegin;
  FBoomListBegin := FBoomListBegin.Next;
  FreeMem(BoomPtr);
// 爆炸火花
  BoomFirePtr^.Next := nil;
  BoomFirePtr^.BombX := Ptr^.Bombx;
  BoomFirePtr^.BombY := ptr^.BombY;
  BoomFirePtr^.BoomW := ptr^.BoomW;
  BoomFirePtr^.BoomA := ptr^.BoomA;
  BoomFirePtr^.BoomS := ptr^.BoomS;
  BoomFirePtr^.BoomD := ptr^.BoomD;
  AddBoomFireList(BoomFirePtr);
// 被炸到的箱子消失
  CheckBoomRange(Ptr);
end;

procedure TFrmMap.SetShoes(Ptr: PTShoesInfo);
var
  PosX, PosY: Integer;
begin
  PosX := Ptr^.ShoesPosX;
  PosY := Ptr^.ShoesPosY;
  FMap[PosX * 20 + PosY] := 5;
end;

function TFrmMap.UpdateUserToList(Ptr: PTPlayerInfo): Integer; // -1 失败 0 成功  1 失败，没有找到要更新的用户
var
  I: Integer;
begin
  if Ptr = nil then
  begin
    Result := -1;
    Exit
  end;
  for I := 0 to Length(FUserList) - 1 do
  begin
    if FUserList[I].UserID = Ptr^.UserID then
    begin
      FUserList[I] := Ptr^;
      Result := 0;
      Exit
    end;
  end;
  if I = Length(FUserList) - 1 then
    Result := 1;
end;

procedure TFrmMap.processAni(Sender: TObject);
var
  x, y, i, j: Integer;
  drawX, drawY: Integer;
  RoleNew: TPlayerInfo;
  RoleOld: TPlayerInfo;
  indexRoleOld: Integer;
  indexRoleNew: Integer;
  steps: Integer;
begin
//  if FUsersChanged then
//  begin
  DrawMap;
  for i := 0 to Length(FUserListNew) do
  begin
    RoleNew := FUserListNew[i];
    if RoleNew.UserName[0] = #0 then
      Continue;
    indexRoleOld := FindInList(FUserListOld, RoleNew);
    if indexRoleOld = -1 then
    begin   //角色新建立
      FBmpRole := bmpS;
      PosX := RoleNew.UserPosX * 40;
      PosY := RoleNew.UserPosY * 40 - (FBmpRole.Height - 40);
      FBmpRole.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(0, 0, piceRoleW, bmpRoleH));
      FUserListOld := FUserListNew;
    end
    else if (FUserListOld[indexRoleOld].UserPosX = RoleNew.UserPosX) and (FUserListOld[indexRoleOld].UserPosY = RoleNew.UserPosY) and ((FMovingRoleIndex = -1) or (indexRoleOld <> FMovingRoleIndex)) then
    begin //角色存在没有动作
      case RoleNew.FaceTo of
        NORTH:
          FBmpRole := bmpN;
        SOUTH:
          FBmpRole := bmpS;
        WEST:
          FBmpRole := bmpWW;
        EAST:
          FBmpRole := bmpE;
      end;
      PosX := RoleNew.UserPosX * 40;
      PosY := RoleNew.UserPosY * 40 - (FBmpRole.Height - 40);
      FBmpRole.DrawTo(pntbx.Buffer, rect(PosX, PosY, W + PosX, PosY + bmpRoleH), Rect(0, 0, piceRoleW, bmpRoleH));
    end
    else if (FUserListOld[indexRoleOld].UserPosX <> RoleNew.UserPosX) or (FUserListOld[indexRoleOld].UserPosY <> RoleNew.UserPosY) then
    begin
       //角色移动
      case RoleNew.FaceTo of
        NORTH:
          FBmpRole := bmpN;
        SOUTH:
          FBmpRole := bmpS;
        WEST:
          FBmpRole := bmpWW;
        EAST:
          FBmpRole := bmpE;
      end;
      if FMovingRoleIndex <> indexRoleOld then
        FMovingRoleIndex := indexRoleOld;

      if FUserListOld[indexRoleOld].UserPosX = RoleNew.UserPosX then
      begin
        FSrcX := FUserListOld[indexRoleOld].UserPosX;
        FSrcY := FUserListOld[indexRoleOld].UserPosY;
        FDesX := RoleNew.UserPosX;
        FDesY := RoleNew.UserPosY;
//        RoleMoveOneStepY;
        TickForRole := TickForRole + 1;
        if TickForRole = 6 then
        begin
          FUserListOld[indexRoleOld] := RoleNew;
          TickForRole := 0;
          FMovingRoleIndex := -1;
        end;
      end
      else if FUserListOld[indexRoleOld].UserPosY = RoleNew.UserPosY then
      begin
        FSrcX := FUserListOld[indexRoleOld].UserPosX;
        FSrcY := FUserListOld[indexRoleOld].UserPosY;
        FDesX := RoleNew.UserPosX;
        FDesY := RoleNew.UserPosY;
//        RoleMoveOneStepX;
        TickForRole := TickForRole + 1;
        if TickForRole = 6 then
        begin
          FUserListOld[indexRoleOld] := RoleNew;
          TickForRole := 0;
          FMovingRoleIndex := -1;
        end;
      end;
    end;
  end;
  for i := 0 to Length(FUserListOld) do
  begin
    RoleOld := FUserListOld[i];
    if RoleOld.UserName[0] = #0 then
      Continue;
    indexRoleNew := FindInList(FUserListNew, RoleOld);
    if indexRoleNew = -1 then
    begin
           //角色死亡
      FMap[RoleOld.UserPosX * 20 + RoleOld.UserPosY] := 0;
    end;
  end;
  pntbx.Invalidate;
end;

procedure TFrmMap.processMove;
var
  Ptr: PTOneMove;
  Role: TBitmap32;
begin
  Ptr := FMoveListBegin;
  case Ptr^.FaceTo of
    NORTH:
      Role := bmpN;
    SOUTH:
      Role := bmpS;
    WEST:
      Role := bmpWW;
    EAST:
      Role := bmpE;
  end;
  if Ptr^.SrcX = Ptr^.DesX then
    RoleMoveOneStepY(Role, Ptr^.SrcX, Ptr^.SrcY, Ptr^.DesY);
  if Ptr^.SrcY = Ptr^.DesY then
    RoleMoveOneStepX(Role, Ptr^.SrcY, Ptr^.SrcX, Ptr^.DesX);
  Inc(tick);
  if tick = 6 then
  begin
    FMoveListBegin := Ptr.Next;
    FreeMem(Ptr);
    tick := 0;
    MoveCheckMap(Ptr^.DesX, Ptr^.DesY);
  end;
end;

end.

